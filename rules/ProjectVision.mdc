---
description: Идея и цели проекта Phrase Drill, стек и архитектура
alwaysApply: true
---

# Идея проекта: тренажёр разговорного английского (Phrase Drill)

На основе этого документа можно давать советы в процессе разработки: предлагать решения, согласованные с целями и архитектурой проекта, напоминать про стек и сценарии, подсказывать, что хранить в БД и как стыковать backend с frontend и LLM.

## Суть

Небольшой учебный проект — веб-приложение для тренировки разговорного английского по темам. Пользователь выбирает тему, запускает упражнение; сервис выдаёт фразы на русском, которые нужно мысленно или вслух перевести на английский. После паузы на обдумывание показывается правильный ответ. Проверка речи не ведётся — формат построен на самопроверке и доверии.

## Стек

- **Backend:** ASP.NET Core Web API (.NET 10)
- **Frontend:** React, Redux
- **БД:** PostgreSQL (темы, упражнения, при необходимости прогресс пользователя)
- **Генерация фраз:** внешняя LLM (API), подобранная под задачу генерации коротких фраз/предложений

## Основной сценарий

1. Пользователь выбирает **тему** (например, «В ресторане», «На работе», «Путешествия»).
2. Запускает **упражнение** по этой теме.
3. Сервис запрашивает у LLM фразы на русском в рамках темы и по одной «подкидывает» пользователю.
4. Пользователь думает и мысленно/вслух переводит фразу на английский (без записи и проверки произношения).
5. По истечении времени (или по нажатию «Показать ответ») отображается корректный английский вариант.
6. Далее — следующая фраза или завершение упражнения.
7. Планируется: постановка упражнения на **паузу** с возможностью продолжить позже.

## Что хранить в БД (PostgreSQL)

- **Темы** — id, название, описание, возможно порядок/категория.
- **Упражнения/сессии** — привязка к теме, дата, статус (в процессе / на паузе / завершено), при необходимости id пользователя.
- При появлении авторизации — **пользователи**, прогресс, настройки (например, длительность паузы перед показом ответа).

Опционально: кэш сгенерированных фраз по темам, чтобы не вызывать LLM при каждом запуске.

## Архитектура

- **Backend (ASP.NET Core Web API):** слой API (Controllers), слой приложения (Services) — оркестрация: темы из БД, генерация/получение фраз через LLM. Доступ к БД через Entity Framework Core, отдельный сервис/клиент для вызова LLM API (с абстракцией для смены провайдера).
  - **Трёхслойная структура:** Controller → Service → Repository. Контроллеры только принимают запросы и возвращают ответы; сервисы содержат бизнес-логику и оркестрацию (в т.ч. вызов LLM); репозитории инкапсулируют доступ к БД (EF Core). Обращение к БД только в репозиториях, не в контроллерах.
  - **API:** RESTful в разумных пределах — ресурсы (themes, sessions и т.д.), стандартные HTTP-глаголы; при этом без фанатизма: допустимы точечные «действия» (пауза, следующая фраза), если так проще и понятнее.
- **Frontend (React + Redux):** экран выбора темы (список с бэкенда), экран упражнения (текущая фраза, таймер/кнопка «Показать ответ», правильный ответ, «Дальше» / «Пауза» / «Завершить»). Redux: темы, текущая сессия, текущая фраза, настройки таймера; асинхронные запросы к API (thunk или RTK Query).
- **Поток данных:** фразы для упражнения либо генерируются по запросу (тема + количество) и отдаются пачкой, либо по одной; таймер «время подумать» на фронте; бэкенд отдаёт фразы и сохраняет состояние сессии при паузе.
- **Деплой:** Docker для backend и фронта, PostgreSQL в контейнере или отдельно; обратный прокси для API и SPA.

## Дополнительно (по мере развития)

- Авторизация: гость vs залогиненный пользователь, сохранение прогресса.
- Конкретная LLM (OpenAI, Yandex GPT и т.д.) и лимиты/стоимость.
- Настройки: длительность паузы перед ответом, количество фраз в сессии.
- Кэш фраз в БД по темам для экономии вызовов LLM.
